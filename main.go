package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"time"

	"github.com/gonutz/w32/v2"
)

// startWireguardTunnel starts a Wireguard tunnel service using the provided
// path to the server configuration file. The function works by creating and
// executing PowerShell commands for installing and setting up the tunnel.
//
// The function makes several attempts to create a private network for the tunnel
// before logging any errors and giving up. It will not attempt to make the network
// private if the version of Windows being used is older than Windows 8.
//
// Parameters:
//     path (string): The file path to the server configuration file for the tunnel service.
//
// Usage:
//     startWireguardTunnel("C:/path/to/config/")
func startWireguardTunnel(path string) {
	// Prints a message indicating that the Wireguard tunnel is starting.
	fmt.Println("\nStarting Wireguard tunnel...")

	// Creates a new PowerShell instance to install the tunnel service.
	installTunnel := NewPowerShell()

	// Formats the command to install the tunnel service.
	installCommand := fmt.Sprintf("&\"wireguard.exe\" /installtunnelservice \"%s\"",
		path+defaultServerConfigFile)

	// Executes the command to install the tunnel service and captures the output and error messages.
	stdOut, stdErr, err := installTunnel.execute(installCommand)

	// Prints the output and error messages if there is an error.
	if err != nil {
		fmt.Printf("\nInstalling Wireguard tunnel:\nStdOut : '%s'\nStdErr: '%s'\nErr: %s",
			strings.TrimSpace(stdOut), stdErr, err)
	}

	// Gets the Windows version.
	winVersion := w32.RtlGetVersion()

	// Don't try making WireGuard network private before Windows 8
	if winVersion.MajorVersion < 6 || (winVersion.MajorVersion == 6 && winVersion.MinorVersion < 2) {
		return
	}

	// Prints a message indicating that the Wireguard tunnel network is being made private.
	fmt.Println("\nTrying to make Wireguard tunnel network private...")

	// Creates a new PowerShell instance to make the network private.
	privateNetworkShell := NewPowerShell()

	// Gets the tunnel name from the default server configuration file.
	tunnelName := strings.Split(defaultServerConfigFile, ".")

	// Formats the command to get the network connection profile.
	networkProfile := fmt.Sprintf("$NetworkProfile = Get-NetConnectionProfile -InterfaceAlias \"%s\"",
		tunnelName[0])

	// Formats the command to enable the private network.
	enablePrivate :=
		`$NetworkProfile.NetworkCategory = "Private"
		Set-NetConnectionProfile -InputObject $NetworkProfile`

	// Formats the script to enable the private network.
	enablePrivateScript := fmt.Sprintf("%s\n%s", networkProfile, enablePrivate)

	// Executes the script to enable the private network and captures the output and error messages.
	stdOut, stdErr, err = privateNetworkShell.execute(enablePrivateScript)

	// Tries to execute the script up to 10 times if there is an error.
	for i := 0; i < 10; i++ {
		time.Sleep(time.Second)
		stdOut, stdErr, err = privateNetworkShell.execute(enablePrivateScript)
		if err == nil {
			break
		}
	}

	// Prints the output and error messages if there is an error.
	if err != nil {
		fmt.Printf("\nMake Wireguard tunnel network private:\nStdOut : '%s'\nStdErr: '%s'\nErr: %s",
			strings.TrimSpace(stdOut), stdErr, err)
	}
}

// stopWireguardTunnel stops the Wireguard tunnel service by executing a
// PowerShell command to uninstall the tunnel service.
//
// The function will log any errors that occur during the process,
// including any output or error messages that are generated by the PowerShell command.
//
// Usage:
//     stopWireguardTunnel()
func stopWireguardTunnel() {
	fmt.Println("Stopping Wireguard tunnel...")
	tunnelName := strings.Split(defaultServerConfigFile, ".")

	installTunnel := NewPowerShell()
	installCommand := fmt.Sprintf("&\"wireguard.exe\" /uninstalltunnelservice %s",
		tunnelName[0])

	stdOut, stdErr, err := installTunnel.execute(installCommand)

	if err != nil {
		fmt.Printf("\nEnable Private Network:\nStdOut : '%s'\nStdErr: '%s'\nErr: %s", strings.TrimSpace(stdOut),
			stdErr, err)
	}
}

// The main function is the entry point of the application. This function first parses command line arguments,
// and then based on these arguments, performs a range of actions such as starting, stopping, or restarting the
// Wireguard server, adding a new Wireguard peer and client config file, and displaying the QR code for a
// specified configuration. The function also loads an existing configuration from a 'config.json' file if
// available and stores any updated configuration back to this file.
//
// The main function also sets up several command-line flags using the 'flag' package, including:
//     -start: Starts the Wireguard server.
//     -stop: Stops the Wireguard server.
//     -restart: Restarts the Wireguard server.
//     -add: Adds a new Wireguard peer and client config file. Creates a server config file if not available.
//     -qrcode: Displays the QR code for the specified configuration.
//
// Usage:
//     To use this program, run it from the command line with one or more of the defined flags.
//     For example, to start the server, you would run:
//         go run main.go -start
func main() {
	var config appConfig
	configExists := false

	startService := flag.Bool("start", false, "Starts Wireguard Server")
	stopService := flag.Bool("stop", false, "Stops Wireguard Server")
	restartService := flag.Bool("restart", false, "Restarts Wireguard Server")
	addPeer := flag.Bool("add", false,
		"Adds new Wireguard peer and client config file. Creates server config file if not available.")
	configIdx := flag.Int("qrcode", -1, "Display QR code for the specified configuration")

	if len(os.Args) == 1 {
		flag.Usage()
		return
	}
	flag.Parse()

	configFilePath := os.Getenv("ALLUSERSPROFILE") + "\\NT KERNEL\\WireSock VPN Gateway\\"

	jsonConfig, err := ioutil.ReadFile(configFilePath + "config.json")

	if err == nil {
		err = json.Unmarshal(jsonConfig, &config)
		if err == nil {
			fmt.Println("Existing configuration loaded successfully.")
			configExists = true
		}
	}

	if *configIdx != -1 {
		if !configExists {
			fmt.Println("Can't display QR code. Configuration does not exist.")
			return
		}
		if len(config.Clients) < *configIdx {
			fmt.Println("Can't display QR code. Requested client index does not exist.")
			return
		}
		config.showClientQrCode(*configIdx - 1)
		return
	}

	if *addPeer {
		if !configExists {
			fmt.Println("Failed to load existing configuration. Starting creating a new one.!")
			err = newConfig(&config)
			if err != nil {
				log.Fatalf("Failed to generate new configuration: %s", err.Error())
			}
		} else {
			fmt.Println("Trying to add new Wireguard client.")
			config.addClient()
		}

		config.updateWireguardConfigFiles(configFilePath)

		config.showClientQrCode(len(config.Clients) - 1)

		jsonConfig, err = json.MarshalIndent(config, "", " ")
		if err == nil {
			err = ioutil.WriteFile(configFilePath+"config.json", jsonConfig, 0666)
		} else {
			fmt.Println("Failed to store the application configuration into config.json!")
		}

		configExists = true
	}

	if *restartService {
		*startService = true
		*stopService = true
	}

	if *startService || *stopService || *restartService {
		_, elevated, err := IsAdminElevated() // Not correct on Windows 7, so show only a warning
		if err != nil || !elevated {
			fmt.Println("Please note to run this application as Administrator to use Start/Stop/Restart flags.")
		}
		if !configExists {
			log.Fatalf("There is no existing configuration to start/stop/restart")
		}
	}

	if *stopService {
		stopWireguardTunnel()
	}

	if *restartService {
		time.Sleep(time.Second)
	}

	if *startService {
		startWireguardTunnel(configFilePath)
	}
}
